# encoding:utf-8import numpy as npfrom torch.utils.data import DataLoaderfrom torch.utils.data import Datasetimport torchimport osfrom PIL import Image, ImageFileImageFile.LOAD_TRUNCATED_IMAGES = Trueclass DyployDataset(Dataset):    def __init__(self, root_dir, transform=None, defect_areas=None):        self.file = root_dir        self.defects = defect_areas        self.transforms = transform    def __len__(self):        return len(self.file)    def __getitem__(self, index):        img_name = self.file[index]  # 图像绝对地址        defect_area = int(self.defects[index])  # 面积值        images = []        try:            image = Image.open(img_name).convert('RGB')            base_image_name = os.path.basename(img_name)            for _transform in self.transforms:                images.append(_transform(image))            source_name = img_name.replace('\\', '/')            return images, source_name, defect_area        except:            for _ in self.transforms:                images.append(None)            return images, None, Nonedef custom_collate_deploy(batch):    images_tensors, address, defects_area = zip(*batch)    cols_num = len(images_tensors[0]) # transforms    rows_num = len(images_tensors)# images    images_batch = None    if None not in address:        for _col in range(cols_num):            temp_image_tensors = []            for _row in range(rows_num):                temp_image_tensors.append(images_tensors[_row][_col])            images_tensor_batch = torch.stack(temp_image_tensors, dim=0)            if images_batch is None:                images_batch = images_tensor_batch            else:                images_batch = torch.cat([images_batch, images_tensor_batch], dim=0)        return images_batch, address, defects_area    else:        for _col in range(cols_num):            temp_image_tensors = []            for _row in range(rows_num):                if images_tensors[_row][_col] is None:                    continue                temp_image_tensors.append(images_tensors[_row][_col])            if len(temp_image_tensors) == 0:                images_tensor_batch = None            else:                images_tensor_batch = torch.stack(temp_image_tensors, dim=0)            if images_batch is None:                images_batch = images_tensor_batch            else:                images_batch = torch.cat([images_batch, images_tensor_batch], dim=0)        if images_batch is None:            return None, None, None        if len(images_batch) == 0:            return None, None, None        else:            address_valid = [address0 for address0 in address if address0 is not None]            defect_area_valid = [defect_area for defect_area in defects_area if defect_area is not None]        return images_batch, address_valid, defect_area_valid# train dataloaderclass TrainDataset(Dataset):    def __init__(self, images_list, labels_list, data_transforms=None, multi_classs=None):        self.data_transforms = data_transforms        self.images_list = images_list        self.labels_list = labels_list        self.multi_class = multi_classs    def __len__(self):        return len(self.labels_list)    def __getitem__(self, item):        images = []        try:            img_name = self.images_list[item]            label = self.labels_list[item]            input_image = Image.open(img_name).convert('RGB')            for _transform in self.data_transforms:                images.append(_transform(input_image))            base_name = os.path.basename(img_name)            try:                tmp_name = base_name.split("@")                multi_label = None                if len(tmp_name) > 4:                    if tmp_name[2] in self.multi_class: # 旧数据格式的 Bincode OP                        multi_label = self.multi_class.index(tmp_name[2])                    elif tmp_name[3] in self.multi_class:# 新数据格式的 Bincode OP                        multi_label = self.multi_class.index(tmp_name[3])            except:                multi_label = None        except:            for _ in self.data_transforms:                images.append(None)            label = None            multi_label = None        return images, label, multi_label# temp-Good dataloaderclass TmpGoodDataset(Dataset):    def __init__(self, images_path, data_transforms, good_label_idnex):        self.data_transforms = data_transforms        self.image_names = os.listdir(images_path)        self.path = images_path        self.label = good_label_idnex    def __len__(self):        return len(self.image_names)    def __getitem__(self, item):        img_name = os.path.join(self.path, self.image_names[item])  # 图像绝对地址        try:            image = Image.open(img_name).convert('RGB')            images = []            for _transform in self.data_transforms:                images.append(_transform(image))            source_name = img_name.replace('\\', '/')            return images, source_name        except:            return None, Nonedef custom_collate_temp(batch):    images_tensors, address = zip(*batch)    cols_num = len(images_tensors[0])    row_num = len(images_tensors)    images_batch = None    if None not in address:        for _col in range(cols_num):            temp_image_tensors = []            for _row in range(row_num):                temp_image_tensors.append(images_tensors[_row][_col])            images_tensor_batch = torch.stack(temp_image_tensors, dim=0)            if images_batch is None:                images_batch = images_tensor_batch            else:                images_batch = torch.cat([images_batch, images_tensor_batch], dim=0)        return images_batch, address    else:        for _col in range(cols_num):            temp_image_tensors = []            for _row in range(row_num):                if images_tensors[_row][_col] is None:                    continue                temp_image_tensors.append(images_tensors[_row][_col])            if len(temp_image_tensors) == 0:                images_tensor_batch = None            else:                images_tensor_batch = torch.stack(temp_image_tensors, dim=0)            if images_batch is None:                images_batch = images_tensor_batch            else:                images_batch = torch.cat([images_batch, images_tensor_batch], dim=0)        if images_batch is None:            return None, None        if len(images_batch) == 0:            return None, None        else:            address_valid = [address0 for address0 in address if address0 is not None]        return images_batch, address_validdef custom_collate_train(batch):    images_tensors, labels, multi_index = zip(*batch)    cols_num = len(images_tensors[0])    rows_num = len(images_tensors)    images_batch = None    # batch size cat    for _col in range(cols_num):        temp_image_tensors = []        for _row in range(rows_num):            if images_tensors[_row][_col] is None:                continue            temp_image_tensors.append(images_tensors[_row][_col])        if len(temp_image_tensors) == 0:            images_tensor_batch = None        else:            images_tensor_batch = torch.stack(temp_image_tensors, dim=0)        if images_batch is None:            images_batch = images_tensor_batch        else:            images_batch = torch.cat([images_batch, images_tensor_batch], dim=0)    if images_batch is None:        return None, None, None    if len(images_batch) == 0:        return None, None, None    else:        labels_multi_index = []        for idx, label_multi in enumerate(multi_index):            out_label_multi = label_multi            if labels[idx] is None:                continue            if out_label_multi is None:                out_label_multi = 99            labels_multi_index.append(out_label_multi)        labels_multi_index = torch.as_tensor(labels_multi_index, dtype=torch.int64)        labels_valid = [label for label in labels if label is not None]        labels_valid = torch.as_tensor(labels_valid, dtype=torch.int64)    return images_batch, labels_valid, labels_multi_index